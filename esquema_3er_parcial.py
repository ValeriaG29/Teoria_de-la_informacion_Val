# -*- coding: utf-8 -*-
"""Esquema_3er_Parcial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S4aUX6LMDgdlgBtcy54lhLwFX6J3pr_l
"""

import random
import time
import math
import hashlib
import numpy as np
from scipy.io import wavfile

#ESQUEMA DE COMUNICACIÓN

def Canal(segmentos, canales):

    datos_recibidos = [[] for _ in range(len(canales))]
    entropias = [[] for _ in range(len(canales))]

    i = 0  # Recorre los segmentos

    while i < len(segmentos):

        for j, canal in enumerate(canales):

            probabilidad_de_error = random.random()

            if i < len(segmentos):
                segmento = segmentos[i]
                segmento_con_ruido = simular_ruido(segmento, probabilidad_de_error, j, i)

                if segmento_con_ruido is not None:
                    canal.append(segmento_con_ruido)
                    i += 1

                    entropia = calcular_Entropia(probabilidad_de_error)
                    entropias[j].append(entropia)

    return datos_recibidos, entropias

def modulacion(segmentos, canales):

    i = 0

    print(f"Canales disponibles: {len(canales)}")

    while i < len(segmentos):

        for canal in canales:

            if i < len(segmentos):
                canal.append(segmentos[i])
                i += 1

def simular_ruido(segmento, probabilidad_de_error, canal_index, paquete_index):

    canal_index += 1
    paquete_index += 1

    if 5 < probabilidad_de_error:

        print(f" XX Paquete {paquete_index} perdido en Canal {canal_index} XX")
        reasignar_paquete = True

        while reasignar_paquete:

            canal_index = (canal_index % len(canales)) + 1
            canal = canales[canal_index - 1]

            if len(canal) < len(segmento):

                canal.append(segmento)
                print(f" -- Paquete {paquete_index} reasignado al Canal {canal_index} --\n")
                reasignar_paquete = False
                return None
    else:
        return segmento

def calcular_Entropia(probabilidad_de_error):

    probabilidad_de_exito = 1 - probabilidad_de_error

    entropia = -(probabilidad_de_error * math.log2(probabilidad_de_error) + probabilidad_de_exito * math.log2(probabilidad_de_exito))

    return entropia


def calcular_entropia_canal(entropias):

    entropias_canal = [sum(entropia) for entropia in entropias]

    return entropias_canal

def calcular_entropia_total(entropias_canal):

    entropia_total = sum(entropias_canal)

    return entropia_total


# Función para calcular el hash de una lista de datos
def calcular_hash(datos):
    hash_objeto = hashlib.sha256()

    for dato in datos:
        # Convertir el dato a bytes antes de agregarlo al hash
        hash_objeto.update(str(dato).encode('utf-8'))

    return hash_objeto.hexdigest()


def busqueda_binaria(lista, dato):

    baja = 0
    alta = len(lista) - 1

    while baja <= alta:
        medio = (baja + alta) // 2

        if lista[medio][0] == dato:
            return medio

        elif lista[medio][0] < dato:

            baja = medio + 1
        else:
            alta = medio - 1

    return -1
# ... (código anterior)

# Función para comprimir datos
def comprimir(datos_audio):
    datos_comprimidos = []

    for dato in datos_audio:
        if dato == 0:
            datos_comprimidos.append(0)
        else:
            datos_comprimidos.append(len(dato))

    return datos_comprimidos

# Función para descomprimir datos
def descomprimir(datos_comprimidos):
    datos_audio = []

    for dato_comprimido in datos_comprimidos:
        if dato_comprimido == 0:
            datos_audio.append(0)
        else:
            datos_audio.extend([1] * dato_comprimido)

    return datos_audio

def leer_datos_desde_archivo(ruta_archivo):
    with open(ruta_archivo, 'r') as archivo:
        contenido = archivo.readlines()

    datos = [tuple(linea.strip().split(':')) for linea in contenido]

    return datos

def texto_a_morse(texto):
    morse_code = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....',
                  'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.',
                  'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
                  'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
                  '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': '/'}

    morse_text = ' '.join([morse_code.get(char.upper(), '') for char in texto])
    return morse_text

# Función para transformar un símbolo Morse en una onda
def generate_sin_wave(frequency, duration, SAMPLE_RATE):
    time_points = np.linspace(0, duration, int(SAMPLE_RATE * duration), False)
    wave = np.sin(2 * np.pi * frequency * time_points)
    return wave


def morse_to_wave(symbol, DOT_DURATION, SAMPLE_RATE):
    if symbol == '.':
        return generate_sin_wave(500, DOT_DURATION, SAMPLE_RATE)
    elif symbol == '-':
        return generate_sin_wave(500, DOT_DURATION * 3, SAMPLE_RATE)
    elif symbol == '/':
        return np.zeros(int(SAMPLE_RATE * DOT_DURATION * 7))  # Espacio entre palabras

def generar_secuencia_morse(texto_en_morse, DOT_DURATION, SAMPLE_RATE):
    morse_wave = np.concatenate([morse_to_wave(char, DOT_DURATION, SAMPLE_RATE) for char in texto_en_morse.replace(' ', '/')])
    morse_wave = morse_wave / np.max(np.abs(morse_wave))
    return morse_wave

def escribir_datos_en_archivo(ruta_archivo, datos):
    with open(ruta_archivo, 'w') as archivo:
        for dato in datos:
            archivo.write(f"{dato}\n")


print("Cargando datos originales del telegrafo...\n")
with open("mensaje_morse.txt", "r") as archivo:
    contenido_telegrafo = archivo.read()


# Convertir texto a Morse
morse_text = texto_a_morse(contenido_telegrafo)

# Dividir los datos en segmentos
segmentos_telegrafo = [morse_text[i:i + 200] for i in range(0, len(morse_text), 200)]

# Crear 5 canales de transmisión
canales_telegrafo = [[] for _ in range(5)]

# Asignar segmentos a los canales
modulacion(segmentos_telegrafo, canales_telegrafo)

print("\nTransmitiendo por telegrafo...\n")
time.sleep(3)
datos_recibidos_telegrafo, entropias_telegrafo = Canal(segmentos_telegrafo, canales_telegrafo)

# Comprimir datos recibidos
print("Comprimiendo datos recibidos...\n")
datos_recibidos_comprimidos = [comprimir(dato) for dato in datos_recibidos_telegrafo]

# Descomprimir datos recibidos
print("\nDescomprimiendo datos recibidos...\n")
datos_recibidos_descomprimidos = [descomprimir(dato) for dato in datos_recibidos_comprimidos]

# Guardar los datos recibidos en un archivo de texto con sus hashes
print("\nGuardando datos recibidos con sus hashes...\n")
datos_recibidos_hashes = [(calcular_hash(dato), dato) for dato in datos_recibidos_descomprimidos]
escribir_datos_en_archivo("datos_recibidos_telegrafo_hashes.txt", datos_recibidos_hashes)

# Calcular la entropía del telegrafo
entropias_canal_telegrafo = calcular_entropia_canal(entropias_telegrafo)
entropia_total_telegrafo = calcular_entropia_total(entropias_canal_telegrafo)

print("Calculando entropía de cada canal del telegrafo...\n")
for i, entropia in enumerate(entropias_canal_telegrafo):
    print(f"Canal {i + 1} (Telegrafo): {entropia:.2f} bits")

print(f'\nLa entropía total del telegrafo es de: {entropia_total_telegrafo:.2f} bits')

# Generar la secuencia Morse en audio
DOT_DURATION = 1
SAMPLE_RATE = 44100
morse_wave = generar_secuencia_morse(morse_text, DOT_DURATION, SAMPLE_RATE)

# Crear el archivo WAV
wavfile.write("datos_recibidos_telegrafo.wav", SAMPLE_RATE, (morse_wave * 32767).astype(np.int16))

print("Archivo 'datos_recibidos_telegrafo.wav' creado.")