# -*- coding: utf-8 -*-
"""Esquema_comunicacion3er_Parcial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ydQv5w0kJmzvcSFpu9jQYWIxq38YwehH
"""

!pip install huffman

import random
import time
import math
import numpy as np
from scipy.io import wavfile
from collections import Counter

# Clase para el nodo Huffman
class NodoHuffman:
    def __init__(self, simbolo, frecuencia):
        self.simbolo = simbolo
        self.frecuencia = frecuencia
        self.izquierda = None
        self.derecha = None

# Función para contar frecuencias en el mensaje binario
def contar_frecuencias(mensaje_binario):
    return Counter(mensaje_binario)

# Función para construir el árbol de Huffman
def construir_arbol_huffman(frecuencias):
    nodos = [NodoHuffman(simbolo, frecuencia) for simbolo, frecuencia in frecuencias.items()]

    while len(nodos) > 1:
        nodos.sort(key=lambda nodo: nodo.frecuencia)
        izquierda = nodos.pop(0)
        derecha = nodos.pop(0)
        nuevo_nodo = NodoHuffman(None, izquierda.frecuencia + derecha.frecuencia)
        nuevo_nodo.izquierda = izquierda
        nuevo_nodo.derecha = derecha
        nodos.append(nuevo_nodo)

    return nodos[0]

# Función para generar el diccionario Huffman
def generar_diccionario_huffman(arbol, codigo_actual='', diccionario={}):
    if arbol.simbolo is not None:
        diccionario[arbol.simbolo] = codigo_actual
    if arbol.izquierda is not None:
        generar_diccionario_huffman(arbol.izquierda, codigo_actual + '0', diccionario)
    if arbol.derecha is not None:
        generar_diccionario_huffman(arbol.derecha, codigo_actual + '1', diccionario)
    return diccionario

# Función para codificar usando Huffman
def codificar_huffman(mensaje_binario):
    frecuencias = contar_frecuencias(mensaje_binario)
    arbol = construir_arbol_huffman(frecuencias)
    diccionario = generar_diccionario_huffman(arbol)
    mensaje_codificado = ''.join(diccionario[byte] for byte in mensaje_binario)
    return mensaje_codificado, diccionario

# Función para decodificar usando Huffman
def decodificar_huffman(mensaje_codificado, diccionario):
    diccionario_inverso = {codigo: simbolo for simbolo, codigo in diccionario.items()}
    mensaje_decodificado = ''
    codigo_actual = ''
    for bit in mensaje_codificado:
        codigo_actual += bit
        if codigo_actual in diccionario_inverso:
            simbolo = diccionario_inverso[codigo_actual]
            mensaje_decodificado += simbolo
            codigo_actual = ''
    return mensaje_decodificado

# Función para mostrar la tabla Huffman
def mostrar_tabla_huffman(diccionario):
    print("Tabla Huffman:")
    print("Símbolo\tCódigo Huffman")
    for simbolo, codigo in diccionario.items():
        print(f"{simbolo}\t{codigo}")

import random
import time
import math
import numpy as np
from scipy.io import wavfile
from collections import Counter
from hashlib import sha256

def hash_binario_huffman(binarios_huffman):
    # Función para realizar el hash de los binarios Huffman con salt (número aleatorio único)
    hash_objeto = sha256()

    # Convertir la lista de binarios a una cadena antes de aplicar encode
    binario_completo = ''.join(binarios_huffman)

    # Generar un número aleatorio único como salt
    salt = str(random.randint(1, 1000000))

    # Concatenar el salt y el binario antes de calcular el hash
    datos_a_hash = salt + binario_completo
    hash_objeto.update(datos_a_hash.encode('utf-8'))

    return hash_objeto.hexdigest()

def handshake(datos_recibidos_telegrafo):
    # Función para realizar el handshake
    handshake = random.randint(1000, 9999)
    print(f"Handshake: {handshake}")
    return handshake

def hash_handshake(handshake):
    # Función para calcular el hash del handshake
    hash_objeto = sha256()
    hash_objeto.update(str(handshake).encode('utf-8'))
    return hash_objeto.hexdigest()

def buscar_en_handshake(hash_paquete, handshake, datos_handshake):
    # Función para buscar el hash del paquete en el handshake usando búsqueda binaria
    datos_handshake.sort()
    baja = 0
    alta = len(datos_handshake) - 1

    while baja <= alta:
        medio = (baja + alta) // 2
        hash_medio = datos_handshake[medio]

        if hash_medio == hash_paquete:
            return handshake[medio]

        elif hash_medio < hash_paquete:
            baja = medio + 1
        else:
            alta = medio - 1

    return None

def encontrar_valor_original(hash_paquete, handshake, datos_handshake):
    # Función para encontrar el valor original del hash
    index = handshake.index(hash_paquete)
    return datos_handshake[index]

# Función para generar una onda sinusoidal de una frecuencia específica
def generate_sin_wave(frequency, duration, SAMPLE_RATE):
    time_points = np.linspace(0, duration, int(SAMPLE_RATE * duration), False)
    wave = np.sin(2 * np.pi * frequency * time_points)
    return wave

# Función para transformar un símbolo Morse en una onda
def morse_to_wave(symbol, DOT_DURATION, SAMPLE_RATE):
    if symbol == '.':
        return generate_sin_wave(500, DOT_DURATION, SAMPLE_RATE)
    elif symbol == '-':
        return generate_sin_wave(500, DOT_DURATION * 3, SAMPLE_RATE)
    elif symbol == '/':
        return np.zeros(int(SAMPLE_RATE * DOT_DURATION * 7))  # Espacio entre palabras

def canal_telegrafo(segmentos, canales):

    datos_recibidos = [[] for _ in range(len(canales))]

    i = 0  # Recorre los segmentos

    while i < len(segmentos):

        for canal in canales:

            if i < len(segmentos):
                segmento = segmentos[i]
                canal.append(segmento)
                i += 1

    return datos_recibidos

def texto_a_morse(texto):
    morse_code = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....',
                  'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.',
                  'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
                  'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
                  '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': '/'}

    morse_text = ' '.join([morse_code.get(char.upper(), '') for char in texto])
    return morse_text

def calcular_Entropia(probabilidad_de_error):

    probabilidad_de_exito = 1 - probabilidad_de_error

    entropia = -(probabilidad_de_error * math.log2(probabilidad_de_error) + probabilidad_de_exito * math.log2(probabilidad_de_exito))

    return entropia

def calcular_entropia_canal(entropias):

    entropias_canal = [sum(entropia) for entropia in entropias]

    return entropias_canal

def calcular_entropia_total(entropias_canal):

    entropia_total = sum(entropias_canal)

    return entropia_total

def leer_datos_desde_archivo(ruta_archivo):
    with open(ruta_archivo, 'r') as archivo:
        contenido = archivo.readlines()

    datos = [linea.strip() for linea in contenido]

    return datos

def escribir_datos_en_archivo(ruta_archivo, datos):
    with open(ruta_archivo, 'w') as archivo:
        for dato in datos:
            archivo.write(f"{dato}\n")

def generar_secuencia_morse(texto_en_morse, DOT_DURATION, SAMPLE_RATE):
    morse_wave = np.concatenate([morse_to_wave(char, DOT_DURATION, SAMPLE_RATE) for char in texto_en_morse.replace(' ', '/')])
    morse_wave = morse_wave / np.max(np.abs(morse_wave))
    return morse_wave

# Cargar contenido del archivo
with open("mensaje_morse.txt", "r") as archivo:
    contenido_telegrafo = archivo.read()

# Convertir texto a Morse
morse_text = texto_a_morse(contenido_telegrafo)

# Dividir los datos en palabras (cambiar según cómo defines una "palabra")
palabras_telegrafo = morse_text.split(' ')

# Calcular hashes para cada palabra
hashes_binarios_huffman = [hash_binario_huffman(palabra) for palabra in palabras_telegrafo]
# Dividir los datos en segmentos
segmentos_telegrafo = [morse_text[i:i + 200] for i in range(0, len(morse_text), 200)]
# Crear 5 canales de transmisión
canales_telegrafo = [[] for _ in range(5)]

# Asignar segmentos y hashes a los canales
for i, segmento in enumerate(segmentos_telegrafo):
    # Cambiar la siguiente línea para usar un hash único por palabra
    hash_segmento = hashes_binarios_huffman[i % len(hashes_binarios_huffman)]
    canal_telegrafo((segmento, hash_segmento), canales_telegrafo)


print("\nTransmitiendo por telegrafo...\n")
time.sleep(3)
datos_recibidos_telegrafo = canal_telegrafo(segmentos_telegrafo, canales_telegrafo)

hashes_binarios_huffman = [(hash_binario_huffman(binario_huffman), binario_huffman) for binario_huffman in datos_recibidos_telegrafo]


# Handshake
handshake_value = handshake(datos_recibidos_telegrafo)
hash_handshake_value = hash_handshake(handshake_value)

def escribir_hashes_en_archivo(ruta_archivo, hashes):
    with open(ruta_archivo, 'w') as archivo:
        for hash_valor, valor in hashes:
            # Escribir el hash y el valor en líneas separadas
            archivo.write(f"{hash_valor}\n{valor}\n")

# Hash del handshake
hash_handshake_value = hash_handshake(handshake_value)

# Guardar hashes en un archivo
escribir_hashes_en_archivo("hashes_binarios_huffman.txt", hashes_binarios_huffman)
escribir_datos_en_archivo("hash_handshake.txt", [(hash_handshake_value, handshake_value)])


# Buscar hash en el handshake
hash_paquete_a_buscar = random.choice(hashes_binarios_huffman)
valor_original_encontrado = encontrar_valor_original(hash_paquete_a_buscar, hashes_binarios_huffman, datos_recibidos_telegrafo)

# Mostrar resultados
print(f"Hash del paquete a buscar: {hash_paquete_a_buscar}")
print(f"Valor original encontrado: {valor_original_encontrado}")


# Calcular la entropía del telegrafo
entropias_telegrafo = [[calcular_Entropia(random.random()) for _ in canal] for canal in canales_telegrafo]
entropias_canal_telegrafo = calcular_entropia_canal(entropias_telegrafo)
entropia_total_telegrafo = calcular_entropia_total(entropias_canal_telegrafo)

print("Calculando entropía de cada canal del telegrafo...\n")
for i, entropia in enumerate(entropias_canal_telegrafo):
    print(f"Canal {i + 1} (Telegrafo): {entropia:.2f} bits")

print(f'\nLa entropía total del telegrafo es de: {entropia_total_telegrafo:.2f} bits')

# Guardar los datos recibidos en un archivo de texto
datos_recibidos_flatten = [item for sublist in datos_recibidos_telegrafo for item in sublist]
escribir_datos_en_archivo("datos_recibidos_telegrafo.txt", datos_recibidos_flatten)
# Obtener datos comprimidos usando Britate Variable

# Generar la secuencia Morse en audio
DOT_DURATION = 1
SAMPLE_RATE = 44100
morse_wave = generar_secuencia_morse(morse_text, DOT_DURATION, SAMPLE_RATE)

# Crear el archivo WAV
wavfile.write("datos_recibidos_telegrafo.wav", SAMPLE_RATE, (morse_wave * 32767).astype(np.int16))

print("Archivo 'datos_recibidos_telegrafo.wav' creado.")